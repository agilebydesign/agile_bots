# Behavior: prioritization

## Behavior Instructions - prioritization

The purpose of this behavior is to organize stories into delivery increments based on business value, dependencies, and risk

Organize stories into delivery increments based on business value, dependencies, and risk

## Action Instructions - validate

The purpose of this action is to validate story graph and/or artifacts against behavior-specific rules, checking for violations and compliance

prioritization: validate increment organization and dependencies

---

**Look for context in the following locations:**
- in this message and chat history
- in `C:/Users/thoma/AppData/Local/Temp/pytest-of-thoma/pytest-3839/test_submit_works_with_differe0/workspace/docs/context/`
- generated files in `C:/Users/thoma/AppData/Local/Temp/pytest-of-thoma/pytest-3839/test_submit_works_with_differe0/workspace/docs/stories/`
  clarification.json, strategy.json

## Step 1: Scanner Violation Review

Error running scanners: Story graph file (story-graph.json) not found in C:\Users\thoma\AppData\Local\Temp\pytest-of-thoma\pytest-3839\test_submit_works_with_differe0\workspace\docs\stories. Cannot validate rules without story graph. Expected story graph to be created by build action before validate.

Please review the validation report file in docs/stories/reports/

Carefully review all scanner-reported violations as follows:
1. For each violation message, locate the corresponding element in the story graph.
2. Open the relevant rule file and read all DO and DON'T examples thoroughly.
3. Decide if the violation is **Valid** (truly a rule breach per examples) or a **False Positive** (explain why if so).
4. Determine the **Root Cause** (e.g., 'incorrect concept naming', 'missing actor', etc.).
5. Assign a **Theme** grouping based on the type of issue (e.g., 'noun-only naming', 'incomplete acceptance criteria').
6. Extract an **Example** from the actual code/content showing the problem.
7. Suggest a clear, concrete **Fix** with a code example informed by DO examples in the rule.

## Step 2: Manual Rule Review

**Rules to validate against (read each file for full DO/DON'T examples):**

### Rule: Map Sequential Spine Vs Optional Paths (Priority 1) [Scanner]
**File:** `story_bot/behaviors/prioritization/rules/map_sequential_spine_vs_optional_paths.json`
**Description:** When mapping stories, carefully distinguish between sequential spine (essential path) and optional paths, alternate routes, or additional functionality that is not strictly essential. Sequential stories form the mandatory flow; optional stories are alternatives, enhancements, or non-essential features.
**DO:** Identify the essential spine and mark optional paths clearly
**DON'T:** Don't mark everything as sequential, don't omit optional markers

### Rule: Design Vertical Slice Increments (Priority 2) [Scanner]
**File:** `story_bot/behaviors/prioritization/rules/design_vertical_slice_increments.json`
**Description:** Create increments that are vertical slices that deliver end-to-end working flows across multiple features/epics, NOT horizontal layers that complete one feature/epic at a time. Each increment must demonstrate complete working flow from start to finish.
**DO:** Design increments as vertical slices - end-to-end flows across multiple epics/features
**DON'T:** Don't design increments as horizontal layers, don't complete one feature/epic at a time

### Rule: Apply Quality Tradeoffs For Minimal Spine (Priority 3) [Manual Check]
**File:** `story_bot/behaviors/prioritization/rules/apply_quality_tradeoffs_for_minimal_spine.json`
**Description:** Apply quality trade-offs to create thin slicing spine and later increments. Decide what quality the spine will have, what parts will be manual, what logic can be excluded, and how to prioritize adding quality in later increments.
**DO:** Make deliberate quality trade-offs to minimize spine size
**DON'T:** Don't build full quality into thin slicing spine, don't skip documenting trade-offs

### Rule: Identify Marketable Increments (Priority 4) [Manual Check]
**File:** `story_bot/behaviors/prioritization/rules/identify_marketable_increments.json`
**Description:** Identify marketable increments of value during prioritization. Name increments with business value terms that stakeholders understand, not technical implementation terms.
**DO:** Name increments with business value terms
**DON'T:** Don't use technical implementation terms in increment names

### Rule: Prioritize Architectural Risk Validation (Priority 5) [Manual Check]
**File:** `story_bot/behaviors/prioritization/rules/prioritize_architectural_risk_validation.json`
**Description:** Prioritize early increments to validate architectural risks and technology decisions. Build risky integrations, test unfamiliar technologies, and validate solution feasibility early to avoid late-stage surprises.
**DO:** Prioritize architectural risk validation in early increments
**DON'T:** Don't defer architectural risks to later increments, don't assume integrations will work without validation


Scanner tools don't cover or catch every rule violation. Do a second pass:
1. Carefully read each rule file, fully reviewing DO and DON'T sections, and every provided example.
2. Inspect all epics, sub-epics, stories, and domain concepts in the story graph for compliance.
3. Compare the properties and content of each element against the rule's requirements.
4. Document any violations the scanner could not find.
5. For each violation, extract an **Example** showing the problem and provide a **Fix** with code example.

## Unified Violations Table

Record ALL findings (scanner + manual) in this comprehensive table. Only include rows for actual violations found:

| Theme | Rule | Location | Valid/FP | Source | Root Cause | Problem Example | Fix with Code Example |
|-------|------|----------|----------|--------|------------|-----------------|----------------------|

**Column Guide:**
- **Theme**: Grouping category (e.g., 'naming violations', 'missing behavior', 'mechanism-oriented language')
- **Rule**: Name of the rule being violated
- **Location**: Path in story graph (e.g., `epics[1].sub_epics[0].name`) or file path
- **Valid/FP**: Valid if rule breach, False Positive if incorrectly flagged (explain why)
- **Source**: Scanner (detected by automated scanner), Manual (found during AI review), Both (flagged by scanner AND confirmed by manual review)
- **Root Cause**: Underlying reason for the violation
- **Problem Example**: Actual code/text showing the issue (e.g., `"Strategy Types"`, `"Create Mobs"`)
- **Fix with Code Example**: Corrected version (e.g., `"Select Strategy"`, `"Assembles Combat Mob"`)

## Step 3: Summarize Findings & Recommendations

Provide a concise summary:
- Report how many **scanner violations** were valid vs false positives.
- Enumerate any **additional manual findings** not caught by scanners.
- Group all violations by recurring theme or pattern.
- Split violations into **Priority Fixes** (must resolve before continuing) and **Optional Improvements**.

Present your summary and await user confirmation before automatically applying or proposing corrections.
prioritization: validate increment organization and dependencies

### Key Questions

- Which areas of the story map carry the most business or delivery risk?
- Which areas are expected to deliver the most value if delivered early?
- Which areas are the most complex or hardest to implement, relative to their value?
- Do you want thin slices to be as end-to-end as possible?
- Are there any components, capabilities, or services that need to be reused across multiple stories or features?
- Are there any project or program constraints that impact delivery order?
- Are there users or groups that must go first to enable others to follow?

### Evidence

Story map from Shape stage (epics, features, and initial story breakdown), Business cases or initiative briefs, Project charters and delivery timelines, Capability or architectural dependency maps, User rollout or onboarding strategies, Risk registers or readiness checklists, Value modeling or impact estimation docs

### Decisions

**increment_slicing_strategy:** What approach are you taking to group the work into thin slices or increments of value, and how are you ensuring they are as small as possible while still being valuable and/or generating learning or reducing risk?

- Delivering End-to-End Journey — supports integrated validation across systems and users
- Validating Impact - Feasibility — reduces uncertainty and derisks critical components early
- Maximizing Earned Value — delivers early impact and builds stakeholder confidence
- Increasing Reuse/Dependency— prevents downstream rework and enables reuse
- Quick Win — implements lowest-complexity paths first
- Validating Impact — validates whether users care, intend to use, or will act on the solution before investing in full delivery (e.g., Wizard of Oz, landing pages, stubs, or mafia offers)


### Assumptions

- Thin slices should provide either value, learning, or risk reduction
- Slices do not need to include all functionality to be useful
- Not every increment must be user-visible if it validates key assumptions
- Some slices may be architectural if they unlock multiple features