{
  "shape": {
    "decisions": {
      "flow_scope_and_granularity": "Intra-system level",
      "drill_down_approach": "Dig deep on behavioral complexity",
      "depth_of_shaping": "Decompose -> Discover all stories listed",
      "drill_down_limits": "Approximate story limit: 10-15 stories",
      "structure_exploration_depth": "Behavioral"
    },
    "assumptions": [
      "this is an assumption"
    ]
  },
  "design": {
    "decisions": {
      "object_instantiation": "Self-Creating Objects",
      "parent_child_management": "Explicit Collection Class",
      "ui_domain_interaction": "Application Service Layer"
    },
    "assumptions": []
  },
  "scenarios": {
    "decisions": {
      "examples_representation": "Verification Data Table",
      "scenario_outline": "Scenario Outline with Examples",
      "scenario_coverage": [
        "Happy Path",
        "Edge Cases"
      ]
    },
    "assumptions": [
      "One story is specified at a time",
      "Acceptance criteria must be testable, unambiguous, and executable",
      "Gherkin syntax or structured language (Given/When/Then) is preferred",
      "Scenarios are written in plain English. When using Scenario Outline, variables are clearly marked and defined in Examples tables with actual test data.",
      "Examples tables when used must include ALL variables used in scenario steps",
      "Examples tables when used must have exact values for both input AND output variables",
      "Every variable when used in scenario steps must have a corresponding column in Examples table",
      "Examples tables when used must have actual test data, not placeholders",
      "Output/expected result variables must be included in Examples tables when used",
      "scnarios follow this pattern",
      "bulk of business logic tests done against the domain layer objects directly",
      "minimal happy path testing done with separate tgests that go theoiugh CLI",
      "JS nodetest for panel test focus on rendering and button layout"
    ]
  },
  "walkthrough": {
    "decisions": {
      "walkthrough_depth": "{\"value\":\"mixed\",\"description\":\"Variable depth - detailed for risky areas, high-level for proven areas\",\"when_to_use\":\"Mixed complexity across system, focus effort where it matters\"}",
      "walkthrough_purpose": [
        "{\"value\":\"architecture_complexity\",\"description\":\"Validate model supports new frameworks, libraries, or architectural patterns\",\"when_to_use\":\"New frameworks being introduced, unfamiliar libraries, novel architectural patterns, design pattern uncertainty\"}"
      ],
      "walkthrough_purpose_reasoning": "CRC model proposes unified OOP hierarchy (DrawIOStoryMap inherits StoryMap, recursive report/update) but current implementation is procedural (StoryIODiagram, DrawIORenderer, DrawIOSynchronizer, standalone functions). The functionality is proven; the architecture is the risk.",
      "detailed_walks": [
        "Render story map \u2014 Scenario 1 (render outline default layout)",
        "Update graph from story map \u2014 Scenario 1 (rename/add/remove stories)",
        "Recursive report generation pattern (Epic \u2192 SubEpic \u2192 Story delegation)"
      ],
      "high_level_walks": [
        "Render story map increments \u2014 diagramType branching",
        "Render story map with acceptance criteria \u2014 AC box extension",
        "Render action diagram section \u2014 behavior-to-diagram mapping"
      ],
      "key_validation_questions": [
        "Does unified API work when data backends differ (XML vs JSON)?",
        "Is recursive per-node report/update viable vs flat comparison?",
        "Where does DrawIOStoryNodeSerializer sit \u2014 can one class handle render and load?",
        "What happens to StoryIODiagram \u2014 replaced or wrapped?",
        "How do ~2000 lines of story_map_drawio_synchronizer.py map to new classes?"
      ],
      "risk_assessment": "HIGH: DrawIOStoryMap (central, doesn't exist), DrawIOStoryNode hierarchy (unified API missing), Recursive report/update (currently flat). MEDIUM: UpdateReport (dict\u2192class), DrawIOStoryNodeSerializer (split across renderer/synchronizer). LOW: LayoutData (dict wrapper), render layout rules (proven), behavior-to-diagram mapping (config)."
    },
    "assumptions": [
      "validate the use of  diff story map / story node extension using consosutient model"
    ]
  },
  "tests": {
    "decisions": {
      "test_scope": "Integration tests",
      "helper_structure": "Create drawio_story_map_helper.py in test/invoke_bot/perform_action/ extending BaseHelper",
      "test_data_fixtures": "Create test/invoke_bot/perform_action/fixtures/ directory with JSON/XML test data files"
    },
    "assumptions": [
      "Tests call NEW domain model classes (DrawIOStoryMap, DrawIOElement, DrawIOStoryNode, UpdateReport, LayoutData) - NOT old synchronizers code",
      "Domain model sources guide implementation: walkthrough realizations (object flows), CRC cards (responsibilities), acceptance criteria (behavior)",
      "Old synchronizers code (StoryIODiagram, DrawIORenderer, DrawIOSynchronizer) used ONLY for algorithm reference - architecture is replaced",
      "Tests use tmp_path workspace for all file operations - no writes to production bot workspace or production story graph",
      "Helper pattern: drawio_story_map_helper.py extends BaseHelper(parent), accessed via helper.drawio_story_map",
      "Test structure: test/invoke_bot/perform_action/test_synchronized_graph_with_rendered_diagram_content.py with classes per story",
      "Test methods named after scenarios: test_render_outline_diagram_from_story_map_with_default_layout",
      "Node panel tests in test/panel/test_render_action_diagram_section.js test DOM rendering with jsdom",
      "All test code uses ASCII-only characters (no Unicode in code, docstrings OK)",
      "Tests should fail naturally if production code doesn't exist - write tests FIRST per TDD"
    ]
  },
  "code": {
    "decisions": {
      "architecture_and_design": "DrawIO classes MUST inherit from base StoryNode/StoryMap hierarchy"
    },
    "assumptions": [
      "DrawIOStoryNode inherits from BOTH DrawIOElement AND StoryNode - shares .children, __iter__, __getitem__, walk(), node_type",
      "DrawIOEpic inherits from DrawIOStoryNode (which inherits StoryNode) - shares .sub_epics, .all_stories, .children iteration",
      "DrawIOSubEpic inherits from DrawIOStoryNode - shares .children iteration",
      "DrawIOStory inherits from DrawIOStoryNode - shares .story_type, .users, .acceptance_criteria, .scenarios",
      "DrawIOStoryMap inherits from StoryMap - shares .epics, .walk(), .all_stories, .save() with no params",
      "DrawIOStoryMap.save() derives output path internally from diagram_type: workspace/docs/story/story-map-{diagram_type}.drawio",
      "DrawIOStoryMap.save() takes no parameters - it knows its own path like StoryMap.save()",
      "No parallel hierarchy - one unified tree where DrawIO nodes ARE StoryNodes with added position/style/serialization"
    ]
  }
}