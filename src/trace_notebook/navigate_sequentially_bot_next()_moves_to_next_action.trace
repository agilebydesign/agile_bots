{
  "cells": [
    {
      "kind": "markdown",
      "value": "## Navigate Sequentially\n*User Story (Bot Behavior)*\n\n### Scenarios\n\n#### Scenario: bot.next() moves to next action (happy_path)\n\nTest: `test_bot_next_navigates_to_next_action_in_workflow`\n\n```gherkin\nGiven Bot is at clarify action\nWhen bot.next() is called\nThen Bot moves to strategy (next action in workflow)\n```\n",
      "language": "markdown",
      "metadata": {
        "section": "story",
        "collapsed": false
      }
    },
    {
      "kind": "markdown",
      "value": "### Test Method: `test_bot_next_navigates_to_next_action_in_workflow`\n\n*File: `test/invoke_bot/navigate_behavior_actions/test_navigate_behavior_and_actions.py` (lines 357-377)*",
      "language": "markdown",
      "metadata": {
        "section": "test_header"
      }
    },
    {
      "kind": "code",
      "value": "    def test_bot_next_navigates_to_next_action_in_workflow(self, tmp_path):\n        \"\"\"\n        Scenario: bot.next() moves to next action\n        GIVEN: Bot is at clarify action\n        WHEN: bot.next() is called\n        THEN: Bot moves to strategy (next action in workflow)\n        \"\"\"\n        # Given: Bot at clarify\n        helper = BotTestHelper(tmp_path)\n        helper.bot.behaviors.navigate_to('shape')\n        helper.bot.behaviors.current.actions.navigate_to('clarify')\n        helper.behaviors.assert_at_behavior_action('shape', 'clarify')\n        \n        # When: Call bot.next()\n        result = helper.bot.next()\n        \n        # Then: Bot moved to strategy\n        assert result['status'] == 'success'\n        assert result['action'] == 'strategy'\n        assert result['behavior'] == 'shape'\n        helper.behaviors.assert_at_behavior_action('shape', 'strategy')",
      "language": "python",
      "metadata": {
        "section": "test",
        "source_file": "test/invoke_bot/navigate_behavior_actions/test_navigate_behavior_and_actions.py",
        "class_name": "TestNavigateSequentially",
        "method_name": "test_bot_next_navigates_to_next_action_in_workflow",
        "start_line": 357,
        "end_line": 377,
        "collapsed": false
      }
    },
    {
      "kind": "markdown",
      "value": "### Referenced Code\n\n*Source files called by test*",
      "language": "markdown",
      "metadata": {
        "section": "code_header"
      }
    },
    {
      "kind": "code",
      "value": "# src/behaviors/behaviors.py\n# Class: Behaviors\n# Methods: current, navigate_to, next\n\nclass Behaviors:\n\n    def __init__(self, bot_name: str, bot_paths: BotPath, allowed_behaviors: Optional[List[str]] = None):\n        import json; from pathlib import Path as P; log_path = P(r'c:\\dev\\augmented-teams\\.cursor\\debug.log'); log_path.parent.mkdir(parents=True, exist_ok=True); log_file = open(log_path, 'a', encoding='utf-8'); log_file.write(json.dumps({'location':'behaviors.py:18','message':'Behaviors.__init__ entry','data':{'bot_name':bot_name},'timestamp':__import__('time').time()*1000,'sessionId':'debug-session','hypothesisId':'H1'})+'\\n'); log_file.close()\n        self.bot_name = bot_name\n        self.bot_paths = bot_paths\n        self._allowed_behaviors = allowed_behaviors\n        self._behaviors: List['Behavior'] = []\n        import json; from pathlib import Path as P; log_path = P(r'c:\\dev\\augmented-teams\\.cursor\\debug.log'); log_file = open(log_path, 'a', encoding='utf-8'); log_file.write(json.dumps({'location':'behaviors.py:22','message':'Before _discover_behaviors','data':{},'timestamp':__import__('time').time()*1000,'sessionId':'debug-session','hypothesisId':'H1'})+'\\n'); log_file.close()\n        self._discover_behaviors()\n        import json; from pathlib import Path as P; log_path = P(r'c:\\dev\\augmented-teams\\.cursor\\debug.log'); log_file = open(log_path, 'a', encoding='utf-8'); log_file.write(json.dumps({'location':'behaviors.py:22','message':'After _discover_behaviors','data':{'behavior_count':len(self._behaviors)},'timestamp':__import__('time').time()*1000,'sessionId':'debug-session','hypothesisId':'H1'})+'\\n'); log_file.close()\n        self._current_index: Optional[int] = None\n        import json; from pathlib import Path as P; log_path = P(r'c:\\dev\\augmented-teams\\.cursor\\debug.log'); log_file = open(log_path, 'a', encoding='utf-8'); log_file.write(json.dumps({'location':'behaviors.py:24','message':'Before load_state','data':{},'timestamp':__import__('time').time()*1000,'sessionId':'debug-session','hypothesisId':'H1'})+'\\n'); log_file.close()\n        self.load_state()\n        import json; from pathlib import Path as P; log_path = P(r'c:\\dev\\augmented-teams\\.cursor\\debug.log'); log_file = open(log_path, 'a', encoding='utf-8'); log_file.write(json.dumps({'location':'behaviors.py:24','message':'After load_state - Behaviors.__init__ exit','data':{},'timestamp':__import__('time').time()*1000,'sessionId':'debug-session','hypothesisId':'H1'})+'\\n'); log_file.close()\n\n    def _load_behavior_from_dir(self, item: Path) -> tuple:\n        behavior_json_path = item / 'behavior.json'\n        if not behavior_json_path.exists():\n            return None\n        try:\n            config = read_json_file(behavior_json_path)\n            order = config.get('order', 999)\n            behavior = Behavior(name=item.name, bot_paths=self.bot_paths, bot_instance=None)\n            return (order, behavior)\n        except Exception as e:\n            logger.warning(f'Failed to load behavior {item.name}: {e}')\n            logger.debug(f'Traceback: {traceback.format_exc()}')\n            return None\n\n    def _discover_behaviors(self) -> None:\n        behaviors_dir = self.bot_paths.bot_directory / 'behaviors'\n        if not behaviors_dir.exists():\n            return\n        behavior_orders = []\n        for item in behaviors_dir.iterdir():\n            if not item.is_dir() or item.name.startswith('_') or item.name.startswith('.'):\n                continue\n            if self._allowed_behaviors is not None and item.name not in self._allowed_behaviors:\n                continue\n            result = self._load_behavior_from_dir(item)\n            if result:\n                behavior_orders.append(result)\n        behavior_orders.sort(key=lambda x: x[0])\n        self._behaviors = [behavior for _, behavior in behavior_orders]\n\n    @property\n    def current(self) -> Optional['Behavior']:\n        if self._current_index is not None and 0 <= self._current_index < len(self._behaviors):\n            return self._behaviors[self._current_index]\n        return None\n\n    @property\n    def names(self) -> List[str]:\n        return [b.name for b in self._behaviors]\n\n    @property\n    def completed_behaviors(self) -> List[str]:\n        completed = []\n        for behavior in self._behaviors:\n            if behavior.is_completed:\n                completed.append(behavior.name)\n        return completed\n\n    @property\n    def remaining_behaviors(self) -> List['Behavior']:\n        return [b for b in self._behaviors if not b.is_completed]\n\n    @property\n    def next_step_command(self) -> Optional[str]:\n        current = self.current\n        if not current:\n            return None\n        remaining_actions = current.actions.remaining_actions\n        if remaining_actions:\n            return f'/{self.bot_name}-{current.name} {remaining_actions[0]}'\n        next_behavior = self.next()\n        if next_behavior and next_behavior.actions.names:\n            return f'/{self.bot_name}-{next_behavior.name} {next_behavior.actions.names[0]}'\n        return None\n\n    @property\n    def first(self) -> Optional['Behavior']:\n        return self._behaviors[0] if self._behaviors else None\n\n    def is_empty(self) -> bool:\n        return len(self._behaviors) == 0\n\n    def find_by_name(self, behavior_name: str) -> Optional['Behavior']:\n        for behavior in self._behaviors:\n            if behavior.name == behavior_name:\n                return behavior\n        return None\n\n    def next(self) -> Optional['Behavior']:\n        next_index = self._current_index + 1\n        if next_index < len(self._behaviors):\n            return self._behaviors[next_index]\n        return None\n    \n    def previous(self) -> Optional['Behavior']:\n        if self._current_index is None or self._current_index <= 0:\n            return None\n        prev_index = self._current_index - 1\n        if prev_index >= 0:\n            return self._behaviors[prev_index]\n        return None\n    \n    def advance(self) -> Dict[str, Any]:\n        if not self.current:\n            return {\n                'status': 'error',\n                'message': 'No current behavior set'\n            }\n        \n        current_behavior = self.current\n        actions = current_behavior.actions\n        if actions.current is None and actions.names:\n            actions.navigate_to(actions.names[0])\n        \n        if actions.is_final_action():\n            actions.close_current()\n            next_behavior = self.next()\n            if next_behavior:\n                self._current_index += 1\n                self.save_state()\n                if next_behavior.actions.names:\n                    next_behavior.actions.navigate_to(next_behavior.actions.names[0])\n                return {\n                    'status': 'success',\n                    'message': f'Advanced to behavior: {next_behavior.name}',\n                    'behavior': next_behavior.name,\n                    'action': next_behavior.actions.current.action_name if next_behavior.actions.current else None\n                }\n            return {\n                'status': 'complete',\n                'message': 'Workflow complete - no more behaviors'\n            }\n        \n        actions.close_current()\n        return {\n            'status': 'success',\n            'message': f'Advanced to action: {actions.current.action_name if actions.current else None}',\n            'behavior': current_behavior.name,\n            'action': actions.current.action_name if actions.current else None\n        }\n    \n    def go_back(self) -> Dict[str, Any]:\n        if not self.current:\n            return {\n                'status': 'error',\n                'message': 'No current behavior set'\n            }\n        \n        current_behavior = self.current\n        back_result = current_behavior.actions.go_back()\n        \n        if back_result['status'] == 'success':\n            return back_result\n        \n        prev_behavior = self.previous()\n        if prev_behavior:\n            self._current_index -= 1\n            self.save_state()\n            if prev_behavior.actions._actions:\n                last_action_name = prev_behavior.actions.names[-1]\n                prev_behavior.actions.navigate_to(last_action_name)\n            return {\n                'status': 'success',\n                'message': f'Went back to behavior: {prev_behavior.name}',\n                'behavior': prev_behavior.name,\n                'action': prev_behavior.actions.current.action_name if prev_behavior.actions.current else None\n            }\n        \n        return back_result\n\n    def __iter__(self) -> Iterator['Behavior']:\n        for behavior in self._behaviors:\n            yield behavior\n\n    def check_exists(self, behavior_name: str) -> bool:\n        return self.find_by_name(behavior_name) is not None\n\n    def navigate_to(self, behavior_name: str):\n        behavior = self.find_by_name(behavior_name)\n        if behavior is None:\n            raise ValueError(f\"Behavior '{behavior_name}' not found\")\n        \n        for i, b in enumerate(self._behaviors):\n            if b.name == behavior.name:\n                self._current_index = i\n                break\n        \n        if self.current and self.current.actions:\n            self.current.actions.load_state()\n        \n        self.save_state()\n\n    def close_current(self):\n        if self._current_index is not None and self.current:\n            if self.current.actions and self.current.actions.current:\n                self.current.actions.close_current()\n            next_behavior = self.next()\n            if next_behavior:\n                self._current_index += 1\n                self.save_state()\n\n    def _get_next_behavior_reminder(self) -> str:\n        try:\n            next_behavior = self.next()\n            if next_behavior:\n                return f\"After completing this behavior, the next behavior in sequence is `{next_behavior.name}`. When the user is ready to continue, remind them: 'The next behavior in sequence is `{next_behavior.name}`. Would you like to continue with `{next_behavior.name}` or work on a different behavior?'\"\n        except Exception as e:\n            logger.debug(f'Failed to get next behavior reminder: {e}')\n            raise\n        return ''\n\n    def save_state(self):\n        if self.current is None or self.bot_paths is None:\n            return\n        workspace_dir = self.bot_paths.workspace_directory\n        state_file = workspace_dir / 'behavior_action_state.json'\n        state_data = {}\n        if state_file.exists():\n            try:\n                content = state_file.read_text(encoding='utf-8')\n                # Try to parse JSON, but handle corrupted files gracefully\n                try:\n                    state_data = json.loads(content)\n                except json.JSONDecodeError as e:\n                    # If JSON is corrupted, try to extract the first valid JSON object\n                    logger.warning(f'State file {state_file} has corrupted JSON: {e}. Attempting recovery...')\n                    # Try to find the first complete JSON object\n                    content_cleaned = content.strip()\n                    # Find the first complete JSON object by looking for balanced braces\n                    brace_count = 0\n                    end_pos = -1\n                    for i, char in enumerate(content_cleaned):\n                        if char == '{':\n                            brace_count += 1\n                        elif char == '}':\n                            brace_count -= 1\n                            if brace_count == 0:\n                                end_pos = i + 1\n                                break\n                    if end_pos > 0:\n                        try:\n                            state_data = json.loads(content_cleaned[:end_pos])\n                            logger.info(f'Recovered state from corrupted file (first {end_pos} chars)')\n                        except json.JSONDecodeError:\n                            logger.warning(f'Could not recover state from corrupted file, starting fresh')\n                            state_data = {}\n                    else:\n                        logger.warning(f'Could not find valid JSON object in corrupted file, starting fresh')\n                        state_data = {}\n            except Exception as e:\n                logger.warning(f'Failed to load state file {state_file}: {e}. Starting with empty state.')\n                state_data = {}\n        state_data['current_behavior'] = f'{self.bot_name}.{self.current.name}'\n        if self.current.actions and self.current.actions.current:\n            state_data['current_action'] = f'{self.bot_name}.{self.current.name}.{self.current.actions.current.action_name}'\n        state_data['timestamp'] = datetime.now().isoformat()\n        state_file.parent.mkdir(parents=True, exist_ok=True)\n        state_file.write_text(json.dumps(state_data, indent=2), encoding='utf-8')\n\n    def _init_to_first_behavior(self) -> None:\n        if self._behaviors:\n            self._current_index = 0\n\n    def _find_behavior_index(self, behavior_name: str) -> int:\n        for i, behavior in enumerate(self._behaviors):\n            if behavior.name == behavior_name:\n                return i\n        return -1\n\n    def _extract_behavior_name_from_state(self, current_behavior_full: str) -> str:\n        if not current_behavior_full:\n            return None\n        parts = current_behavior_full.split('.')\n        if len(parts) >= 2:\n            return '.'.join(parts[1:])\n        return None\n\n    def load_state(self):\n        if self.bot_paths is None:\n            self._init_to_first_behavior()\n            return\n        workspace_dir = self.bot_paths.workspace_directory\n        state_file = workspace_dir / 'behavior_action_state.json'\n        if not state_file.exists() or not self._behaviors:\n            self._init_to_first_behavior()\n            return\n        try:\n            state_data = json.loads(state_file.read_text(encoding='utf-8'))\n            behavior_name = self._extract_behavior_name_from_state(state_data.get('current_behavior', ''))\n            if behavior_name:\n                idx = self._find_behavior_index(behavior_name)\n                if idx >= 0:\n                    self._current_index = idx\n                    if self.current:\n                        self.current.actions.load_state()\n                    return\n            self._init_to_first_behavior()\n        except Exception:\n            self._init_to_first_behavior()\n\n    def initialize_state(self, confirmed_behavior: str):\n        if self.bot_paths is None:\n            raise ValueError('Cannot initialize state without bot_paths')\n        behavior_obj = self.find_by_name(confirmed_behavior)\n        if behavior_obj is None:\n            raise ValueError(f\"Behavior '{confirmed_behavior}' not found. Available behaviors: {', '.join(self.names)}.\")\n        workspace_dir = self.bot_paths.workspace_directory\n        state_file = workspace_dir / 'behavior_action_state.json'\n        action_names = behavior_obj.actions.names\n        first_action = action_names[0] if action_names else 'clarify'\n        self.navigate_to(confirmed_behavior)\n        state_data = {'current_behavior': f'{self.bot_name}.{behavior_obj.name}', 'current_action': f'{self.bot_name}.{behavior_obj.name}.{first_action}', 'completed_actions': [], 'timestamp': datetime.now().isoformat()}\n        state_file.parent.mkdir(parents=True, exist_ok=True)\n        state_file.write_text(json.dumps(state_data, indent=2), encoding='utf-8')",
      "language": "python",
      "metadata": {
        "section": "code",
        "source_file": "src/behaviors/behaviors.py",
        "symbol": "Behaviors",
        "collapsed": true
      }
    }
  ]
}